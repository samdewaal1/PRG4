{"mappings":"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","sources":["app.js"],"sourcesContent":["// Based somewhat on this article by Spicy Yoghurt\nconst app = new PIXI.Application({ backgroundColor: 0x111111 });\ndocument.body.appendChild(app.view);\n\n// Options for how objects interact\n// How fast the red square moves\nconst movementSpeed = 0.05;\n\n// Strength of the impulse push between two objects\nconst impulsePower = 5;\n\n// Test For Hit\n// A basic AABB check between two different squares\nfunction testForAABB(object1, object2) {\n    const bounds1 = object1.getBounds();\n    const bounds2 = object2.getBounds();\n\n    return bounds1.x < bounds2.x + bounds2.width\n        && bounds1.x + bounds1.width > bounds2.x\n        && bounds1.y < bounds2.y + bounds2.height\n        && bounds1.y + bounds1.height > bounds2.y;\n}\n\n// Calculates the results of a collision, allowing us to give an impulse that\n// shoves objects apart\nfunction collisionResponse(object1, object2) {\n    if (!object1 || !object2) {\n        return new PIXI.Point(0);\n    }\n\n    const vCollision = new PIXI.Point(\n        object2.x - object1.x,\n        object2.y - object1.y,\n    );\n\n    const distance = Math.sqrt(\n        (object2.x - object1.x) * (object2.x - object1.x)\n        + (object2.y - object1.y) * (object2.y - object1.y),\n    );\n\n    const vCollisionNorm = new PIXI.Point(\n        vCollision.x / distance,\n        vCollision.y / distance,\n    );\n\n    const vRelativeVelocity = new PIXI.Point(\n        object1.acceleration.x - object2.acceleration.x,\n        object1.acceleration.y - object2.acceleration.y,\n    );\n\n    const speed = vRelativeVelocity.x * vCollisionNorm.x\n        + vRelativeVelocity.y * vCollisionNorm.y;\n\n    const impulse = impulsePower * speed / (object1.mass + object2.mass);\n\n    return new PIXI.Point(\n        impulse * vCollisionNorm.x,\n        impulse * vCollisionNorm.y,\n    );\n}\n\n// Calculate the distance between two given points\nfunction distanceBetweenTwoPoints(p1, p2) {\n    const a = p1.x - p2.x;\n    const b = p1.y - p2.y;\n\n    return Math.hypot(a, b);\n}\n\n// The green square we will knock about\nconst greenSquare = new PIXI.Sprite(PIXI.Texture.WHITE);\ngreenSquare.position.set((app.screen.width - 100) / 2, (app.screen.height - 100) / 2);\ngreenSquare.width = 100;\ngreenSquare.height = 100;\ngreenSquare.tint = '0x00FF00';\ngreenSquare.acceleration = new PIXI.Point(0);\ngreenSquare.mass = 3;\n\n// The square you move around\nconst redSquare = new PIXI.Sprite(PIXI.Texture.WHITE);\nredSquare.position.set(0, 0);\nredSquare.width = 100;\nredSquare.height = 100;\nredSquare.tint = '0xFF0000';\nredSquare.acceleration = new PIXI.Point(0);\nredSquare.mass = 1;\n\n// Listen for animate update\napp.ticker.add((delta) => {\n    // Applied deacceleration for both squares, done by reducing the\n    // acceleration by 0.01% of the acceleration every loop\n    redSquare.acceleration.set(redSquare.acceleration.x * 0.99, redSquare.acceleration.y * 0.99);\n    greenSquare.acceleration.set(greenSquare.acceleration.x * 0.99, greenSquare.acceleration.y * 0.99);\n\n    const mouseCoords = app.renderer.plugins.interaction.mouse.global;\n\n    // Check whether the green square ever moves off the screen\n    // If so, reverse acceleration in that direction\n    if (greenSquare.x < 0 || greenSquare.x > (app.screen.width - 100)) {\n        greenSquare.acceleration.x = -greenSquare.acceleration.x;\n    }\n\n    if (greenSquare.y < 0 || greenSquare.y > (app.screen.height - 100)) {\n        greenSquare.acceleration.y = -greenSquare.acceleration.y;\n    }\n\n    // If the green square pops out of the cordon, it pops back into the\n    // middle\n    if ((greenSquare.x < -30 || greenSquare.x > (app.screen.width + 30))\n        || greenSquare.y < -30 || greenSquare.y > (app.screen.height + 30)) {\n        greenSquare.position.set((app.screen.width - 100) / 2, (app.screen.height - 100) / 2);\n    }\n\n    // If the mouse is off screen, then don't update any further\n    if (app.screen.width > mouseCoords.x || mouseCoords.x > 0\n        || app.screen.height > mouseCoords.y || mouseCoords.y > 0) {\n        // Get the red square's center point\n        const redSquareCenterPosition = new PIXI.Point(\n            redSquare.x + (redSquare.width * 0.5),\n            redSquare.y + (redSquare.height * 0.5),\n        );\n\n        // Calculate the direction vector between the mouse pointer and\n        // the red square\n        const toMouseDirection = new PIXI.Point(\n            mouseCoords.x - redSquareCenterPosition.x,\n            mouseCoords.y - redSquareCenterPosition.y,\n        );\n\n        // Use the above to figure out the angle that direction has\n        const angleToMouse = Math.atan2(\n            toMouseDirection.y,\n            toMouseDirection.x,\n        );\n\n        // Figure out the speed the square should be travelling by, as a\n        // function of how far away from the mouse pointer the red square is\n        const distMouseRedSquare = distanceBetweenTwoPoints(\n            mouseCoords,\n            redSquareCenterPosition,\n        );\n        const redSpeed = distMouseRedSquare * movementSpeed;\n\n        // Calculate the acceleration of the red square\n        redSquare.acceleration.set(\n            Math.cos(angleToMouse) * redSpeed,\n            Math.sin(angleToMouse) * redSpeed,\n        );\n    }\n\n    // If the two squares are colliding\n    if (testForAABB(greenSquare, redSquare)) {\n        // Calculate the changes in acceleration that should be made between\n        // each square as a result of the collision\n        const collisionPush = collisionResponse(greenSquare, redSquare);\n        // Set the changes in acceleration for both squares\n        redSquare.acceleration.set(\n            (collisionPush.x * greenSquare.mass),\n            (collisionPush.y * greenSquare.mass),\n        );\n        greenSquare.acceleration.set(\n            -(collisionPush.x * redSquare.mass),\n            -(collisionPush.y * redSquare.mass),\n        );\n    }\n\n    greenSquare.x += greenSquare.acceleration.x * delta;\n    greenSquare.y += greenSquare.acceleration.y * delta;\n\n    redSquare.x += redSquare.acceleration.x * delta;\n    redSquare.y += redSquare.acceleration.y * delta;\n});\n\n// Add to stage\napp.stage.addChild(redSquare, greenSquare);"],"names":["$6b17f08f738443dc$var$app","PIXI","Application","backgroundColor","document","body","appendChild","view","$6b17f08f738443dc$var$greenSquare","Sprite","Texture","WHITE","position","set","screen","width","height","tint","acceleration","Point","mass","$6b17f08f738443dc$var$redSquare","ticker","add","delta","x","y","mouseCoords","renderer","plugins","interaction","mouse","global","redSquareCenterPosition","toMouseDirection","angleToMouse","Math","atan2","redSpeed","p1","p2","a","b","hypot","$6b17f08f738443dc$var$distanceBetweenTwoPoints","cos","sin","object1","object2","bounds1","getBounds","bounds2","$6b17f08f738443dc$var$testForAABB","collisionPush","vCollision","distance","sqrt","vCollisionNorm","vRelativeVelocity","impulse","$6b17f08f738443dc$var$collisionResponse","stage","addChild"],"version":3,"file":"index.e5c36142.js.map"}